# Mercury Layer Protocol

## Preliminaries

The SE and each owner are required to generate private keys securely. Owners are required to verify the status of UTXOs (this can be achieved via a wallet interface, and requires connection to an Electrum server or fully verifying Bitcoin node). In the following, elliptic curve points (public keys) are depicted as upper case letters, and field elements (private keys) as lower case letters. Elliptic curve point multiplication (i.e. generation of public keys from private keys) is denoted using the `.` symbol. The generator point of the elliptic curve standard used (e.g. secp256k1) is denoted as `G`. All arithmetic operations on secret values (in Zp) are modulo the field of the EC standard.  

In addition, a public key encryption scheme is required for blinded private key information sent between parties. This should be compatible with the EC keys used for signatures, and ECIES is used. The notation for the use of ECIES operations is as follows: `Enc(m,K)` denotes the encryption of message `m` with public key `K = k.G` and `Dec(m,k)` denotes the decryption of message `m` using private key `k`.

All transactions are created and signed using segregated witness, which enables input transaction IDs to be determined before signing and prevents their malleability. 

## Deposit

A user wants to deposit an amount of BTC into the platform, and they request that the SE initialize the process. To begin, the user must provide a valid `token_id` (UUID), which will be listed in the the server token database. This `token_id` is generated by the SE on payment of a deposit fee (via a separate lighning, bitcoin or other out of band payment). 

1. The depositor (Owner 1) generates a private key: `o1`
2. Owner 1 then calculates the corresponding public key `O1` and sends it to the SE: `O1 = o1.G`
3. Owner 1 requests a key share from the SE with a valid `token_id` and amount value `A`. 
4. The SE then generates a private key: `s1` (the SE private key share), calculates the corresponding public key and sends it to Owner 1: `S1 = s1.G` along with a `statechain_id` (UUID). The SE then stores `s1`, `S1` and `A` indexed with `statechain_id`. 
5. Owner 1 then adds the public key they receive by their own public key to obtain the shared (aggregated) public key `P` (which corresponds to a shared private key of `p = o1 + s1`): `P = O1 + S1`
6. Owner 1 creates and broadcasts a funding transaction (`Tx0`) to pay an amount `A` to the address corresponding to `P`. This defines the UTXO `TxID:vout` (the outpoint). 
8. Owner 1 creates an unsigned *backup transaction* (`Tx1`) that pays the `P` output of `Tx0` to an address `O1`, and sets the `nLocktime` to the initial future block height `h0` (where `h0 = cheight + hinit`, `cheight` is the current Bitcoin block height and `hinit` is the initial locktime specified by the server).
9. Owner 1 cooperates with SE to generate a valid signature on `Tx1`

### Signature generation

To generate a signature on `Tx1`, the owner first computes the sighash `m1`. 
Owner 1 then generates a random ephemeral nonce `r2_1` and blinding nonce `b1` and computes `R2_1 = r2_1.G`
Owner 1 then requests a co-signing from the SE sending commitments: `SHA256(R2_1)` and `SHA256(b1)`. 
SE stores the commitments for `statechain_id` and generates a random `r1_1` and computes `R1_1 = r1_1.G`. `R1_1` is returned to Owner 1. 
Owner 1 then computes `R_1 = R1_1 + r2_1.G + b1.P`, `e1 = SHA256(P||R_1||m1)` and `c1 = e1 + b1` and sends `c1` to the SE. 
The SE then computes `sig1_1 = r1_1 + c1.s1` and sends to Owner 1 (and stores `c1` with `statechain_id`). 
Owner 1 computes `sig2_1 = r2_1 + c1.o1` and `sig_1 = sig1_1 + sig2_1`. The full signature `(sig_1,R_1)` is then added to `Tx1`. 

10. `Tx1` is verified and stored by Owner 1, along with the values `b1`, `R1_1` and `e1`. 
11. The SE then adds the public key `S1` to the list of current statechain SE keys and publishes. 

## Transfer

Owner 1 wishes to transfer the value of the deposit `A` to a new owner (Owner 2) (as a payment or as part of a swap). The protocol then proceeds as follows:

### Sender

1. The receiver (Owner 2) generates a private key `o2`. They then compute the corresponding public key `O2 = o2.G`.
2. `O2` is the Owner 2 'address' and is communicated to Owner 1 (or published) in order for them to send the statecoin to it.
3. Owner 1 then creates a new unsigned backup transaction `Tx2` paying the output of `Tx0` to the address `O2`, and sets the `nLocktime` to `h0 - (n-1)*c` where `c` is the confirmation interval and `n` is the owner number (i.e. 2). 
4. Owner 1 cooperates with SE to generate a valid signature on `Tx2`

### Signature generation

To generate a signature on `Tx2`, the owner first computes the sighash `m2`. 
Owner 1 then generates a random ephemeral nonce `r2_2` and blinding nonce `b2` and computes `R2_2 = r2_2.G`
Owner 1 then requests a co-signing from the SE sending commitments: `SHA256(R2_2)` and `SHA256(b2)`. 
SE stores the commitments for `statechain_id` and generates a random `r1_2` and computes `R1_2 = r1_2.G`. `R1_2` is returned to Owner 1. 
Owner 1 then computes `R_2 = R1_2 + r2_2.G + b2.P`, `e2 = SHA256(P||R_1||m1)` and `c2 = e2 + b2` and sends `c2` to the SE. 
The SE then computes `sig1_2 = r1_2 + c2.s1` and sends to Owner 1 (and stores `c2` with `statechain_id`). 
Owner 1 computes `sig2_2 = r2_2 + c2.o1` and `sig_2 = sig1_2 + sig2_2`. The full signature `(sig_2,R_2)` is then added to `Tx2`.

5. SE generates a random key `x1` and sends it to Owner 1. 
6. Owner 1 then computes `t1 = o1 + x1` and encrypts it with the Owner 2 public key (from the address): `Enc(t1,O2)`
7. Owner 1 then concatinates the `Tx0` outpoint with the Owner 2 public key (`O2`) and signs it with their key `o1` to generate `SC_sig_1`. 
8. Owner 1 then sends Owner 2 a message containing five objects:
	a. All `K` (here `K = 2`) signed backup transactions (`Txi i=1,...,K`): `Tx1` and `Tx2`
	b. For each backup transaction signature (`bi`,`R2_i i=1,...,K`): `b1`,`b2`,`R2_1` and `R2_2`. 
	c. `SC_sig_1`
	d. `Enc(t2,O2)`
	e. `statechain_id`

> At this point the Owner 1 has sent all the information required to complete the transfer to Owner 2 and is no longer involved in the protocol. Owner 2 then verifies the correctness and validity of the objects. 

### Receiver

1. Owner 2 verifies that the latest backup transaction pays to their key `O2` and that the input (`Tx0`) is unspent. 
2. Owner 2 takes the list of previous `K` backup transactions (`Txi i=1,...,K`) and for each one `i` verifies:
	a. The signature is valid. 
	b. The `nLocktimes` are decremented correctly (i.e. the latest `TxK` has the lowest). 
	c. Retreives `ci`, and commitments `SHA256(R2_i)` and `SHA256(bi)` from the SE. 
	d. Verifies the commitments to `R2_i` and `bi` and verfies that `ci = bi + SHA256(P||R_i||mi)` (where `mi` is the sighash of `Txi`). 
3. Owner 2 queries SE for 1) The total number of signatures generated for `statechain_id`: `N` and 2) Current SE public key: `S1`. 
4. Owner 2 then verifies that `K = N` and then `O1 + S1 = P`

The SE key share update then proceeds as follows:

5. Owner 2 decrypts object `t1`: `Dec(t1,o2)` and then computes `t2 = t1 - o2`. 
6. Owner 2 then sends `t2` to the SE. 
7. SE the updates the private key share `s2 = s1 + t2 - x1 = s1 + x1 + o1 - o2 - x1 = s1 + o1 - o2`

> `s2` and `o2` are now key the private key shares of `P = (s2 + o2).G` which remains unchanged (i.e. `s2 + o2 = s1 + o1`), without anyone having learnt the full private key. Provided the SE deletes `s1`, then there is no way anyone but the current owner (with `o2`) can spend the output.

8. The SE then adds the public key `S2` to the list of active key shares and publishes. 

## Orderly Withdrawal

The current owner of a coin can at any time withdraw from the platform by simply co-signing a withdrawal transaction. The server cannot identify a withdrawal, but the coin can no longer be transferred to a new owner because the server will have produced an additional signature that cannot be verified as a valid backup by a receiver. 

Withdrawal proceeds as follows:

1. The current owner (e.g. Owner 2) creates an unsigned transaction `TxW` that spends `Tx0` to a withdrawal address `W`.
2. The owner then co-signs this transaction with the SE (as above).  `TxW` is broadcast. 
3. The owner then sends the SE a withdrawal notification (with their current `user_id`) that the coin is withdrawn so the SE can remove the coin public from the published key share list. 

## Backup withdrawal

In the case that the SE disappears or does not cooperate with the current owner, the current owner can reclaim their funds to an address they control by submitting their backup transaction when the `nLocktime` is reached. 
