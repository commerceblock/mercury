

// deposit() messages:
// 0. 2P-ECDSA to gen shared key P
// 1. user sends funding tx outpoint, B1, C1
// 2. Co-op sign kick-off tx (generated by SE)
// 3. Co-op sign back-up tx (generated by user)

use bitcoin::Address;
use bitcoin;
use bitcoin::consensus::encode::serialize;
use bitcoin::blockdata::transaction::TxIn;
use bitcoin::util::amount::Amount;

use crate::ClientShim;
use crate::state_entity::util::{ build_tx_0, build_tx_k, build_tx_1};

use super::super::utilities::requests;
use super::super::wallet::Wallet;
use hex;



const PATH_PRE: &str = "deposit";

#[derive(Serialize, Deserialize)]
pub struct DepositMessage1 {
    txid: String,
    vout: u32,
    backup_pubkey: String,
    proof_pubkey: String
}

pub fn deposit(mut wallet: Wallet, client_shim: &ClientShim, inputs: Vec<TxIn>, funding_addr: Address, amount: Amount) ->(String, String) {
    // make funding tx
    let tx_0 = build_tx_0(&inputs, &funding_addr, &amount).unwrap();
    println!("tx_O: {:?}",tx_0);

    // first message
    let deposit_first_msg = DepositMessage1{
        txid: tx_0.txid().to_string(),
        vout: 0,
        backup_pubkey: String::from("backup_pubkey"),
        proof_pubkey: String::from("proof_pubkey")
    };

    let resp: (String, String) =
        requests::postb(client_shim, &format!("{}/{}/first", PATH_PRE, wallet.private_share.id),&deposit_first_msg).unwrap();

    // make kick-off tx
    let mut tx_k = build_tx_k(&inputs.get(0).unwrap(), &funding_addr, &amount).unwrap();
    wallet.sign_tx_input(client_shim, &mut tx_k, 0, &funding_addr, amount.as_sat());
    println!("tx_k: {:?}",tx_k);

    // make back-up tx
    let mut tx_b = build_tx_1(tx_k.input.get(0).unwrap().clone(), &funding_addr, &amount).unwrap();
    wallet.sign_tx_input(client_shim, &mut tx_b, 0, &funding_addr, amount.as_sat());
    println!("tx_b: {:?}",tx_k);
    println!("{}",hex::encode(serialize(&tx_k)));

    return resp;
}
